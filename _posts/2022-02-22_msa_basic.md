---
layout: single
title:  "[MSA] - MSA 설계 접근법과 패턴"
excerpt: "MSA 아키텍처 설계 및 패턴, 유의사항 등"

categories:
  - MSA
tags:
  - [MSA]

toc: true
toc_sticky: true
 
date: 2022-02-22
last_modified_at: 2022-02-22
---
# MSA 설계
* 퍼온금 [출처](https://www.msaschool.io/operation/introduction/)

## 접근법과 분석패턴
### Approach #1: 마이크로서비스 아키텍처
초기의 마이크로서비스는 서비스의 자율성과 독립성, 서비스에 최적화된 저장소(Polyglot Persistence) 선택이 가능한 아키텍처로 고안되었습니다. 그러나, 서비스간 호출 시, 동기식 API 방식 (Requeste & Response)을 주로 사용함으로 인해 타임 커플링(Time Coupling)이라는 약점이 존재했습니다.

타임 커플링된 서비스들은 서비스 블로킹(Blocking) 우려와 한 서비스에서 발생한 장애가 타 서비스로 전파될 수 있는 약점을 가지고 있습니다. 이는 웹 스케일 기반 시스템에서는 치명적 단점으로, 이를 회로 차단(Circuit Breaking) 등의 방법으로 극복하려 하였습니다.

./../../images/msasc/image1.df59cee.cfeedd12cb9002774ec84b609cd55647.png

### Approach #2: 이벤트 드리븐(Event Driven) 아키텍처
이를 보완한 것이 최근 각광받고 있는 이벤트 기반(EDA)의 3세대 마이크로서비스입니다. 도메인에서 발생하는 이벤트를 분산된 큐를 통해 브로드캐스팅(BroadCasting)하고 Pub/Sub을 통해 상호 커뮤니케이션하는 아키텍처를 가집니다.

./../../images/msasc/image2.1fc590d.c0f91660b5afea026d0b4a82264dfd18.png

예를 들어, 주문이 발생하였을 때, 직접 배송팀에다 ‘’배송을 준비하세요.’라고 지시하는 것은 주문팀의 입장에서는 그다지 중요한 것이 아닙니다. 주문팀은 배송팀이 배송을 하던 말던 관심이 없다는 것입니다.

REST방식(직접 호출)으로 서로 통신할 경우, 요청자는 다음 액션을 수행하기 위해 응답이 도착할 때까지 기다려야 하는 블로킹(Blocking) 즉, 타임 커플링이 일어납니다.

만약, 주문팀이 발생한 사실에 대해 비동기 기반 큐(single Source Of Truth)에 “주문이 발생하였습니다.” 라고 신고만 하고, 이어지는 액션을 배송팀이 알아서 수행해도 됩니다.
이처럼 발생한 사실을 ‘신고’하고, 신고된 사실을 ‘구독’하는 패턴의 아키텍처가 이벤트 드리븐(Event Driven) (또는, 화이트보드 패턴) 아키텍처입니다.

그렇게 되면 초창기 MSA에서는 배송팀의 비즈니스 프로세스가 주문팀이 호출해 실행되던 방식이, 이벤트 드리븐 기반 MSA에선 배송팀이 직접 이벤트에 반응하여 실행하는 방식으로 실행 주체가 바뀌게 됩니다.

신설된 마케팅팀 또한, 주문팀의 주문 발생으로 수행해야 할 비즈니스 프로세스가 있다면, 단순하게 주문팀의 “주문이 발송하였습니다.” 라는 이벤트에 대해, 마케팅팀도 반응하여 수행하면 된다는 것입입니다.

이벤트 드리븐 아키텍처를 적용함으로써 얻어지는 장점 중의 하나는 폴리글랏 퍼시스턴스입니다. 각 마이크로서비스 팀들은 이제 나만의 데이터베이스를 가질 수 있습니다. 자기 만의 스토리지를 자기만의 아키텍처를 적용하여 구성할 수 있다는 것입니다.

주문팀은 사용자의 주문 정보만 관리하고, 상품팀은 전혀 다른 관점으로 상품의 재고 정보만을 관리합니다. 배송팀 또한, 주문 ID에 대해 배송 상태만 가집니다.

사업 초기, 모노리식 구조에선 간결한 스키마 였으나 서포팅 업무가 늘어남에 따라 주문팀 테이블의 컬럼이 많아지고, 여러 팀의 참조 Constraints로 인해, 점진적으로 분리가 불가능한 캐노니컬 모델 구조로 변모하게 됩니다.

./../../images/msasc/image3.8fd9c5a.96793f1be58796aeeb486e8658b4fa06.png

이는 곧 대대적인 합의와 대대적인 리팩토링을 통해서만 수정이 가능한 비용 집약적 결과를 양산하게 됩니다.

그러나, 이벤트드리븐 아키텍처에서는 이벤트의 원천을 통해 각 팀이 필요에 의해 디자인하는, 디자인 책임이 분산된 환경을 추구함으로 모노리식에서의 데이터 참조 이슈가 없어집니다.

### Approach #3: BizDevOps 프로세스
비즈데브옵스는 비즈니스 유저를 뜻하는 ‘비즈’와 ‘데브옵스’가 결합된 의미로, 고객의 니즈를 인풋으로, 이를 개발하고 운영하는 것에 있어 단절을 최소화하는 것을 목적으로 합니다.

조직적으로는 Vertically aligned 되어 있어야 하고, 도구적으로는 이벤트스토밍을 적용해 그 결과 모델을 코드화하여, 자동화된 DevOps환경에서 운영하는 선 순환적 사이클이 비즈데브옵스 프로세스입니다.

이를 수행하는 방식(A way of working)이 흔히 알고 있는 스크럼으로, 스크럼과 위에 언급된 3가지 프랙티스가 버물러질 때, 비로소 ‘Agile’이 실현되는 것입니다.

./../../images/msasc/image4.bc84cb6.2e4347def6c6d40a18f22686ee1f6853.png

## 도메인 주도 설계
소프트웨어의 개발이 어려운 이유는 업무의 복잡성에서 시작됩니다. 개발자가 소프트웨어를 구현하는 복잡성보다 소프트웨어로 구현하고자 하는 기능(업무)에 대한 복잡성이 더 큽니다.

그래서, 업무를 가장 잘 이해하는 해당분야 전문가와 개발자 사이의 소통을 중심으로 특정 도메인을 개념적으로 표현한 모델을 통해, 여러 관계자들이 동일한 모습으로 도메인을 이해하고, 도메인 지식을 공유하는 것이 중요합니다.

고객의 요구사항이 모델로 유연하게 설계되고, 이 모델로부터 구현이 자연스럽게 연결되어야 한다는 사상이 Domain Driven Design 입니다.

이때, 가장 중요한 점은 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안되고, 각 하위 도메인마다 별도로 모델을 만들어야 합니다. 모델의 각 구성요소는 특정 도메인으로 한정할 때, 비로소 의미가 명확해지기 때문입니다.

### 도메인 모델
> 도메인 모델이란 특정 도메인을 개념적으로 표현한 것입니다. 예를 들어, 쇼핑몰의 주문 도메인은 쇼핑몰에서 주문하기 위해 상품 수량을 선택하고, 배송지 정보를 입력합니다. 선택한 상품 가격과 수량으로 지불 금액을 계산하고 결제 수단을 선택합니다.
>
> 주문한 뒤에도 배송 전이면 배송지 주소를 변경하거나 주문을 취소할 수 있습니다. 이 주문 도메인을 객체 모델로 구성하면 아래와 같습니다.

./../../images/msasc/image1.974fa74.f06e0d17233d6afcde389357594c9d22.png

위 그림은 객체를 이용한 도메인 모델입니다.
도메인을 이해하려면 도메인이 제공하는 기능과 도메인의 주요 데이터 구성을 파악해야 하는데, 이런 면에서 객체 모델은 도메인을 모델링하기에 적합합니다.

위 객체 모델은 도메인의 모든 내용을 담고 있지는 않지만 이 모델을 보면 주문(Order)은 주문번호와 지불할 총 금액이 있고, 배송정보(Shipping Information)를 변경할 수 있음을 알 수 있습니다.
또한, 주문을 취소할 수 있다는 것도 알 수 있습니다.

즉, 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움이 됩니다.

이러한 도메인은 다수의 하위 도메인으로 구성됩니다. 각 하위 도메인이 다루는 영역은 서로 다르기 때문에 같은 용어라도 하위 도메인마다 의미가 달라질 수 있습니다.

예를 들어, 상품 도메인 내에서 상품이 상품가격, 상품이미지 URL, 재고 수량 등의 상세 내용을 담고 있는 ‘정보’를 의미한다면 배송 도메인의 상품은 고객에게 실제 배송되는 ‘물리적인 상품’을 의미합니다.

도메인에 따라 용어의 의미가 결정되므로, 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안됩니다. 상품과 배송 도메인 모델을 구분하지 않고 하나의 다이어그램에 함께 표시한다면, 다이어그램에 표시한 ‘상품’은 상품 도메인의 상품인지, 배송 도메인의 상품인지 제대로 이해하기가 힘듭니다.

모델의 각 구성요소는 특정 도메인을 한정(Bounded)할 때, 비로소 의미(Context)가 완전해지기 때문에, ‘상품’의 의미가 통용되는 경계를 구분(Boundary Definition)하고 그 경계 내에서 별도로 도메인 모델을 만들어야 합니다.

#### Bounded Context (한정된 문맥)
[도메인 모델과 경계]
상품 도메인에서의 상품, 배송 도메인에서의 상품, 주문 도메인에서의 상품은 이름만 같지만 실제로 의미하는 것이 다릅니다.
상품 도메인에서의 상품은 상품 이미지, 상품명, 상품 가격, 상품 상세 설명과 같은 상품 정보가 위주라면 주문 도메인에서의 상품은 주문 대상이 되는 객체이며, 배송 도메인에서의 상품은 고객에게 배송되는 물리적 상품을 나타냅니다. 또한, 상품 도메인에서 물리적으로 하나인 상품은 주문 및 배송 도메인에서는 여러 개 존재할 수 있습니다.

논리적으로 같은 존재처럼 보이지만, 하위 도메인에 따라 서로 다른 용어를 사용하는 경우도 있습니다. 시스템을 사용하는 사람을 회원도메인에서는 회원이라고 부르지만, 주문 도메인에서는 주문자라고 부르고, 배송 도메인에서는 보내는 사람이라 부르기도 합니다.

SW 도메인과 건축 도메인에서도 동일한 용어지만 두 도메인 내에서의 의미가 서로 다른 예를 찾을 수 있는데, SW 도메인에서의 ‘프로젝트’가 현업이 요구하는 시스템을 개발하기 위한 전체 과정을 일컫는다면, 건축 도메인에서의 ‘프로젝트’는 사람이 주거하기 위한, 또는 생업에 필요한 건축물을 짓는 과정입니다.

‘아키텍처’란 용어도 SW 도메인에서는 서버, 네트워크, 소프트웨어 구성도나 ERD, UML과 같은 다이어그램 등을 지칭하나, 건축 도메인에서의 ‘아키텍처’는 건축물 구축에 필요한 평면도와 같은 설계 도면을 의미합니다.

./../../images/msasc/image2.978a99b.eddd1fbbce7583fb6ffce63b17fba68f.png

이렇듯, 도메인마다 같은 용어라도 의미가 다르고, 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 정확하게 표현할 수는 없으며, 올바른 도메인 모델을 개발하려면 하위 도메인마다
모델을 만들어야 합니다.

이 때, 여러 하위 도메인이 섞이기 시작하면 모델의 의미가 약해지기 때문에, 각 모델은 명시적으로 구분되는 경계를 가져서 서로 섞이지 않도록 해야 하는 것이 중요합니다.

#### [Bounded Context]
모델은 특정한 경계 문맥(Context) 내에서 정확히 구분 가능한 완전한 의미를 가지는데, 이렇게 구분되는 경계를 DDD에서 바운디드 컨텍스트(Bounded Context) 라고 부릅니다.

즉, 바운디드 컨텍스트는 동일한 컨텍스트의 범위를 표현하는 경계로 해당 경계 내에서 모델은 특정한 의미를 지니고 특정한 일을 수행합니다.

바운디드 컨텍스트는 모델의 경계를 결정하며, 한 바운디드 컨텍스트는 논리적으로 하나, 또는 하나 이상의 모델을 가짐니다.

바운디드 컨텍스트는 도메인 구성원들이 사용하는 언어를 기준으로 구분 가능합니다. 쇼핑몰의 ‘상품’, 및 ‘회원’ 이라는 용어에 대해, 주문/결제 도메인과 배송 도메인 각각 서로 의미하는 바가 다르기 때문에, 두 도메인은 서로 다른 컨텍스트로 분리됩니다.

./../../images/msasc/image3.bda6eff.2c72f34e03210bdc139290f4110017f9.png

바운디드 컨텍스트는 도메인 모델을 구분하는 경계가 되기 때문에 바운디드 컨텍스트는 구현하는 서브 도메인에 알맞은 모델을 포함합니다.
같은 상품이라 하더라도 상품 바운디드 컨텍스트와 주문 바운디드 컨텍스트의 ‘상품’은 각 컨텍스트에 맞는 모델을 가집니다.

#### [Ubiquitous Language (도메인 언어)]
도메인 모델을 구분 짓는 경계인 바운디드 컨텍스트내에는 다양한 이해 관계자들이 존재합니다.
도메인 업무에 능통한 도메인 전문가, 개발이 가능한 뼈대를 세우는 아키텍트, 실제 서브 도메인 서비스를 구축하는 개발자가 포함될 수 있으며, 이들은 담당하는 각 서브 도메인의 모든 권한을 가집니다.

이러한 각 도메인별 소속 구성원들 간에는 원활한 의사 소통에 필요한 보편적 언어가 사용되는데 이를 도메인 언어, 또는 유비쿼터스 언어(Ubiquitous Language)라고 합니다.

./../../images/msasc/image4.9fa36e9.258e3a832419176042872cf3e8239c62.png

다시 말해, 한정된 맥락인 Bounded Context 내에서 협업 구성원들간 보편적으로 통용되는 도메인 언어가 유비쿼터스 언어입니다.

이러한 도메인 언어가 보편적이지 않다면, 개발자가 사용하는 용어를 도메인 전문가가 이해하지 못해, 도메인 전문가가 이해하는데 추가 비용이 들어갑니다.

구성원들이 각자의 언어를 사용하는 경우, 의사소통이 힘들어 상대방이 내뱉은 단어를 내가 사용하는 단어로 번역해서 이해해야 하고, 서로 협의된 내용에 대해서도 각자 해석이 달라지지 않도록 수식어를 달아야 합니다.

의사소통은 물론, 이벤트스토밍, 도메인 모델링, 프로그램 개발에 이르기까지 일관된 용어로 소통, 문서작성 뿐만 아니라 코드개발까지 일관된 언어가 사용되어야 바운디드 컨텍스트의 경계가 견실하게 유지될 수 있는 것입니다.

## 이벤트스토밍
이벤트스토밍은 Event와 BrainStorming의 합성어로 Domain Expert와 개발 전문가가 함께 모여 워크샵 형태로 진행되는 방법론입니다. DDD 방법론 중, 복잡한 UML다이어그램이나 도구 없이 수행할 수 있어 MSA를 구현하는데 가장 최적의 방법론입니다.

이벤트스토밍은 시스템에서 발생하는 이벤트를 중심(Event-First)으로 분석하는 기법으로 특히, Non-Blocking, Event-driven한 MSA 기반 시스템을 분석에서 개발까지 필요한 도메인에 대한 빠른 이해를 도모하는데 유리합니다.

기존의 유즈케이스나 클래스 다이어그래밍 방식은 고객 인터뷰를 통해 요구사항을 정제하고, 상세 설계를 통한 엔티티 구조를 인지하는 방식이었으나, 이벤트스토밍은 별다른 사전 훈련된 지식과 도구없이 진행할 수 있습니다.

./../../images/msasc/image1.d72f1f4.03e2cc6e54aac02dffaff10ef26ee876.png

진행 과정은 참여자 워크숍 방식의 방법론으로 결과는 스티키 노트를 벽에 붙힌 것으로 결과가 남으며, 오렌지 스티키 노트들의 연결로 비즈니스 프로세스가 도출되고 이들을 이후 BPMN과 UML등으로도 정제하여 전환할 수 있습니다.

### 개념
이벤트스토밍은 도메인에 관련된 모든 이해 관련자가 모여, 화이트보드 벽면에 주요 이벤트(Event)를 중심으로 업무들 간의 상호 연관성을 찾기 위해, 유일한 도구인 스티키 노트(Sticky Notes)로 진행하는 MSA DDD를 위한 워크숍 기반 최상의 실천 방법론입니다.

### 수행 방법
이벤트스토밍에 필요한 화이트 보드 벽면과 수행에 필요한 오렌지, 라일락, 스카이블루, 노랑, 초록, 퍼플, 분홍색의 스티커를 준비합니다.

./../../images/msasc/image2.25ecf91.c432d468e1642bb18bcf3023815549b8.jpeg

Domain expert 와 기획자, 개발 전문가와 함께 사용자 시나리오, 또는 업무 요건을 리뷰합니다.

가장 먼저, 발생 가능한 Event를 무작위로 도출하고, Policy, Command, Aggregate 순서로 이벤트를 중심으로 스티커별 해당 내용을 정의하고 발생시간 순서로 벽면에 부착합니다.

Bounded Context 를 설정하고 서브 도메인 간의 컨텍스트 매핑을 통해 BC간의 정보 참조의 릴레이션을 정의합니다.

#### 스티커 유형
이벤트스토밍에 필요한 스티커 색상별 내포하는 의미는 아래와 같습니다.

./../../images/msasc/image3.46136f7.7bbe536d5f61bfa80cecd3c7db266e8b.png

#### Step 1. [Event 정의]
가장 먼저 우리 서비스에서 발생하는 비즈니스 이벤트를 도출합니다. 용어의 네임스페이스를 구지 나누려 하지 말고 가급적 현업이 사용하는 용어를 그대로 사용(Ubiquitous Language)하여 오렌지색 스티커에 이벤트를 기술하고 이를 벽면에 붙입니다.

비즈니스 이벤트는 과거형으로 작성하는데 도메인 내부에 상태가 변화되고 난 결과가 이벤트 입니다.

./../../images/msasc/image4.2bbca33.6bba5d9c593f7074d1552bd205019e68.png

#### Step 2. [Policy 정의]
이벤트스토밍의 두번째 수행 대상은 폴리시(Policy) 도출입니다.

폴리시(Policy)는 이벤트가 발생한 후 연이어 발생하는 반응형 액션으로, 한 서비스 이벤트에 대해 수행되어야 할 타 서비스의 액션들로, 먼저 정의된 이벤트 아래에 덧대어 붙입니다.
하나의 이벤트에 반응하여 수행되어야 할 폴리시는 여러 팀에서 도출된 멀티 액션이 존재할 수 있습니다.

./../../images/msasc/image5.fa8269c.4d56b91e467335dc1590eef1101924a0.png

#### Step 3. [Command 도출]
세번째로 Event를 발생시키는 행위인 커맨드를 도출하는데, 도메인 내의 어떠한 상태 변화를 일으키는 서비스를 말합니다.
웹 페이지 내에서 버튼을 클릭하는 User Decision이 여기에 해당됩니다.
도출된 커맨드는 이벤트 스티커 앞쪽에 붙여, 스티커를 통한 나레이션(Narration)이 되도록 정렬합니다.

./../../images/msasc/image6.e6340cf.e6eaaf7555e3b22086a8a7e08a08358c.png

#### Step 4. [Actor 정의]
Actor는 커맨드를 발생시키는 주체(사람, 시스템, 등)를 말합니다. 액터는 담당자 또는 시스템이 될 수 있으며, 직관적으로 파악될 수 있는 액터의 경우, 표시하지 않아도 무방합니다. 도출된 액터는 유저 스토리에 가까운 나레이션이 가능하도록 해당 커맨드 스티커 왼쪽에 배치합니다.

./../../images/msasc/image7.30df413.15ce0f19d3b57fa8165bbeb4a6508583.png

#### Step 5. [Aggregate 정의]
다섯번째로, 어그리게잇을 도출합니다. 어그리게잇은 ‘결합물’을 의미하는데 어떠한 도메인 객체를 중심으로 하나의 ACID한 트랜잭션에 묶여 변화되어야 할 객체의 묶음을 도출하고, 그것들을 커맨드, 이벤트와 함께 묶습니다.

./../../images/msasc/image8.c9c4c4d.0fee0a3d2d856605ac1c436215ed1070.png

Step 6. [Bounded Context 도출]
Bounded Context는 동일한 문맥으로 효율적으로 업무 용어(도메인 클래스)를 사용할 수 있는 객체 범위를 뜻합니다. 하나의 BC는 하나 이상의 어그리게잇을 원소로 구성될 수 있습니다. 이 BC를 마이크로서비스 구성 단위로 정하게 되면 이를 담당하는 팀내의 커뮤니케이션이 효율화 됩니다.

./../../images/msasc/image9.3b24fc3.04c28fb46523584bf7a76ec354b722ec.png

#### Step 7. [Context 매핑]
바운디드 컨텍스트까지 도출된 이후에 BC간 정보 참조 릴레이션 설정 (혹은, 이벤트가 발생한 이후 동반된 행위의 호출 관계를 선으로 표시)하는 작업을 ‘컨텍스트 매핑’이라고 합니다. 컨텍스트간 매핑 정보만 보더라도 전체 도메인 서비스의 참조 토폴로지(Topology)를 한 눈에 파악 가능합니다.

./../../images/msasc/image10.64e2d1d.b8c0087dcbfb79b84faa1dc2309547cd.png

위 예시에서 ‘주문이력에 추가’라는 폴리시(비즈니스 업무) 시작 주체에 따라 크게 2가지 토폴로지를 고려할 수 있는데, 이벤트를 발행하는 주체인 주문관리에서 해당 폴리시를 시작하는 ‘오케스트레이션’ 방식과 이벤트를 수신하는 주체인 마케팅관리에서 폴리시를 시작하는 ‘코레오그래피’ 방식으로 구분합니다.

#### Orchestration(오케스트레이션)
오케스트레이션은 이벤트를 발행하는 주체인 주문관리에서 모든 폴리시를 호출하는 방식입니다.

./../../images/msasc/image11.7426fad.691cf6dddb919ed7a5a6c182bf3591b8.png

이는 주문관리 서비스에서 발생한 이벤트인 ‘주문 생성됨’, ‘주문정보 변경됨’, ‘주문상태 변경됨’에 붙여진 모든 폴리시의 Owner 서비스마다 커맨드를 노출하고, 이벤트를 생성하는 주문 서비스에서 이 커맨드를 동기 방식(Request & Response)으로 호출하는 방식으로 구현됩니다.

그러나, 이러한 방식은 서비스간 커플링이 높으며, 폴리시를 호출한 서비스(여기서는 주문관리)는 폴리시가 수행 완료될 때까지 대기상태에 빠지게 되므로, 시스템 블로킹(Blocking)이 생길 우려가 높습니다.

또한, 호출당하는 폴리시를 가진 시스템이 얘기치않은 장애(System Fault)에 빠진 경우, 이를 호출하는 서비스에까지 장애가 전파되는 악순환의 우려가 있습니다.

#### Choreography(코레오그래피)
코레오그래피는 폴리시를 구현하는 주체인 배송, 또는 상품관리에서 자율적으로 폴리시를 실행하는 방식입니다.

주문관리 서비스에서 발생(Publish)하는 이벤트들에 대해, 폴리시 Owner 서비스들이 관심 있는 이벤트에 반응(Subscribe)하여 자율적으로 서비스를 구동함으로써 Orchestration방식이 가진 서비스간 커플링이 전혀 없으며, 이벤트를 수신하는 신규 서비스의 추가 및 이벤트를 수신하던 기존 서비스의 삭제가 아주 자유롭게 수행 가능합니다.

또한, 주문관리 서비스 입장에서도 호출당하는 폴리시를 가진 시스템의 얘기치않은 장애(System Fault)에 대해, 이 방식은 완전히 자유롭다는 것이 가장 큰 장점입니다.

./../../images/msasc/image12.179003c.a0f816833ae9b56914b432211aa1b165.png

## 서비스 서열과 역학관계
마이크로 서비스들 간에는 서열이 존재합니다. 이 서열로 인하여 서비스간의 통신 방법이나 리소스 할당 정책등을 정할 수 있습니다.

1. 무엇을 우선적으로 챙길 것인가?
2. 어느 마이크로 서비스의 인터페이스를 더 중요하게 관리할 것인가?
3. 마이크로서비스간 트랜잭션의 묶음을 어떻게 할 것인가?
4. 무엇을 우선적으로 줄일 것인가?

### 무엇을 우선적으로 챙길 것인가?
회사가 점점 커지면서 제공하는 서비스는 조금씩 많아 지게 되는데, 이럴때 마이크로 서비스의 서열을 체크하여 집중해야할 서비스를 결정 할 수 있습니다.

회사에서 버릴수 없는 핵심 기능을 Core Domain 이라고 할 수 있습니다. 아마도 가장 처음에 회사를 생성하게된 핵심 비지니스 라고 할 수 있습니다. 쇼핑몰 시스템에서 주문, 카탈로그 서비스등 이 기능을 제공하지 않으면 회사가 망하는 도메인입니다.

기업의 핵심 경쟁력이 아닌, 직접 운영해도 좋지만 상황에 따라 아웃소싱 가능한 영역을 Supportive Domain 이라고 부를 수 있고, 이는 2순위로 회사에서 가져가야 할 영역입니다. 쇼핑몰 시스템에서 재고관리, 배송, 회원관리 서비스 등이 이에 해당 됩니다. 예를 들어 배송서비스는 직접 운영을 한다면 배송상태를 직접 챙길수 있는 이점이 있지만, 경쟁 회사에서 배송을 더 잘한다면 차라리 외주를 주고, 코어 도메인에 더 집중을 하는게 경쟁력이 더욱 올라갈 것입니다.

서열의 마지막 순위로 다른 회사의 경쟁력이 너무 뛰어나서 오히려 만들면 손해가 나는 서비스가 있을 수 있습니다. 혹은 기업 경쟁력과 무관한 서비스가 있는데, 이를 General Domain 이라고 부른다. 이 영역은 가능하면 구현을 하지 말고, SaaS 서비스를 사용하거나 솔루션을 사는 방법이 더 비용을 아끼는 방법이 될 것입니다. 쇼핑몰 시스템에서 결제, 빌링 서비스 등이 이 영역에 해당 할 수 있습니다. 예를들어 결제시스템을 직접 만든다면, 각종 카드사별 연동과, 지불 방법별 연동 등을 구축해야 하지만, 외부 서비스를 사용하면 PG 사 모듈만 심는 것으로 해결이 될 수 있습니다.

### 어느 마이크로 서비스의 인터페이스를 더 중요하게 관리할 것인가?

./../../images/msasc/image4.df6d994.7b6eb18bbe243b09830511f1353b3ebc.png

서비스간의 서열에 따라서 인터페이스간의 역학관계가 생성됩니다.

 1. Core Domain 은 각 팀끼리 서비스가 분리 되어 있어도, 비슷한 개발 수준 역량을 가지고 있을 확률이 높습니다. 또한 핵심 기능을 분리한 경우일수도 있습니다. 코어 도메인간의 관계는 Shared-Kernel 도 허용이 가능합니다. 쇼핑몰 시스템에서 주문과 상품 서비스가 예시가 될수있습니다. 두팀은 그정도 기술적 합의와 수준이 올라가 있는 상황이지만 KPI 는 달라서 서비스를 나눈 상황으로 볼 수 있습니다. 주문을 하기 위해서는 상품 정보가 필수로 필요하니 상품 도메인 클레스를 같이 공유하여 쓸 수 있습니다.

> Shared-Kernel :
> 두개의 MS 가 호출을 주고 받을때 필요한 도메인 클레스들을 라이브러리 형태로 공유하는것입니다. 코드를 공유하고, 심지어 코드를 커밋할수있는 권한까지 공유 하기도 합니다. 상당히 강한 파워를 가진 MS 끼리 허용될수 있습니다.
> Shared-Kernel 을 Shared-Database 라고 생각하면 안됩니다.

 2. Core Domain 과 Supportive Domain 간의 ‘interfacing’ 은 Conformist 관계가 될 수 있습니다. 서비스들 끼리 인터페이스를 맞추려면 코드의 수정이 필요 할 수있는데, 높은 서열의 서비스가 중요도가 낮은 서비스를 위하여 자신의 코드를 수정해 가면서 인터페이스를 맞추는 경우는 없을 것입니다.

> Conformist :
> 힘이 없기 때문에 업스트림에서 주는대로 쓰는 것입니다. 업스트림의 api 가 바뀌면 다운스트림에서 알아서 바꿔야 하는 관계입니다. 예를들어 facebook 의 api 를 사용하여 어플리케이션을 개발 한다고 치면, 특정 api 가 필요하다고 facebook 에 요청을 해도 들어주지가 않을 것입니다.

 3. Core Domain 과 General Domain(외부서비스) 간의 관계는 Anti-corruption Layer 가 필요 할 수도 있습니다. 예를 들어 내부 시스템에서는 메세지 방식을 사용하는데 외부 시스템의 api 를 사용하기 위해서는 두 서비스의 통신방식을 해석하고 변환을 해주는 또 다른 서비스가 필요 할 것입니다.

> Anti-corruption Layer :
> 두 시스템 간의 통신을 변환하여, 다른 응용 프로그램이 해당 디자인 및 기술 방식을 손상시키지 않도록 하여 해당 시스템을 변경되지 않은 상태로 유지하는 방식입니다.

### 마이크로서비스간 트랜잭션의 묶음을 어떻게 할 것인가?

./../../images/msasc/image5.cbab2cf.6cc3d235ec02e5f6e2f110bc0f6b0739.png

서비스간의 서열에 따라서 서로간의 트랜잭션 방식을 다르게 선택 할 수 있습니다.

Core Domain 간에 강결합을 사용하는 경우가 생깁니다. 주문시 재고를 확인해야 하는 경우도 있을 수 있고, 재고가 없을 경우 주문이 안되는 식의 설계가 있을 수도 있습니다.
이럴때는 ACID Transaction 으로 두개의 서비스를 묶어 주고, 중요도에 따라서 2PC 방식으로 서비스와 통신이 되는지 확인이 필요 할 수도 있습니다.

Core Domain 과 서열이 낮은 서비스간의 통신은 강한 트랜잭션을 연결해야할 이유가 없습니다. 강 결합을 한다는 것은 항상 상대방 서비스가 정상작동을 해야 한다는 가정이 있습니다. 상품 추천이 안되거나 배송이 처리되지 않는다고 해서 주문을 못 받으면 안됩니다.
Core Domain 과 Supportive Domain간 의 연결은 서로간의 서비스에 영향이 없도록 비동기 혹은 Event-Driven 방식으로 처리를 하는게 좋다. 혹은 상품 추천같이 자체적으로 UI 가 있는 경우 UI-MashUp 도 좋은 방법입니다.

### 무엇을 우선적으로 줄일 것인가?

./../../images/msasc/image6.2665e34.6d720de2da9b00269805d2e159125860.png

쇼핑몰에서는 사용자의 요청이 몰려서 서비스에 과부화가 걸리는 상황이 생길 수 있습니다. 이럴때 서비스를 스케일 아웃을 하여 해결을 하게 되는데, 리소스가 한정되어 있다면 Core Domain 을 확장하기 위하여 Supportive Domain 을 중지시킬 수 있습니다.

쇼핑몰에서 배송 서비스는 주문이 폭주하는 시간에 배송 처리를 안하고, 야간에 서비스를 시작하여 처리를 해도 됩니다. 상품 추천 서비스도 주문이 폭주하여 장애가 일어나기 직전인 상황에서는 주문서비스를 살리기 위하여 리소스를 넘겨주는 선택을 할 수도 있습니다.

핵심 서비스인 주문 서비스가 죽었다면 배송처리와 상품추천은 의미가 없어진다. 또한 주문서비스와 배송서비스가 강결합으로 묶여있다면 서비스를 줄이는 선택은 할 수 없을 것입니다. 이렇듯 각각의 마이크로 서비스 간에는 중요도에 따라 우선순위와 역학관계가 존재합니다.

## 아키텍처 설계
### Inner 아키텍처
아래와 같은 육각형 모형의 아키텍처를 헥사고날 아키텍처라고 합니다.
이는 가운데 영역인 비지니스 로직 (도메인 영역)을 손상시키지 않고 프로그램을 구성하도록 고안된 아키텍처입니다.

예를 들어, 우리의 서비스에 외부로 부터 입력되는 데이터는 다양한 형식을 가지고 있을 수 있습니다. 데이터가 xml 이나 json 형식으로 올 수도 있고, 요청되는 프로토콜도 Rest, RPC 방식등을 가지고 있을 수 있습니다.

결국 이렇게 들어온 각종 데이터를 객체로 변환을 시켜야 하는 작업이 필요한데, 이러한 로직들을 도메인 영역에서. 처리를 한다면 (예를들어 객체 안쪽에서 변환작업 처리 등) 도메인 영역은 비대하여지고, 가독성이 떨어질 것 입니다. DDD 에서 말하는 잘 짜여진 코드는 ‘도메인을 보았을때 비지니스 흐름이 보여져야 한다.’ 라고 말합니다. 가독성이 떨어지고 코드가 복잡해지면 결국 잘 짜여진 코드가 될수 없다는 말입니다.

그리하여 나온 방법이 어뎁터를 사용하여 외부에서 들어오는 입력(input)과, 외부로 호출하려는 출력(output)을 처리하는 방식입니다. 어뎁터를 여러개 만들수 있는 구조를 가져서 상황에 맞는 어뎁터를 붙였다가 떼었다가 할수 있도록 구성합니다. 이러한 방법이 헥사고날 아키텍처의 핵심입니다.

그림을 좀더 살펴 보면, 가운데 노란색은 비지니스 영역입니다. 그리고 파란색 도형은 외부로부터의 입력을 컨트롤러 클레스를 이용하여 분리 하였습니다. 컨트롤러에서 변환작업이 있을 것입니다.

하단에 데이터 베이스와의 연결도 어뎁터 패턴으로 분리를 합니다.예를 들어 데이터베이스에 종속적인 Query 를 직접 사용하였다면, 데이터베이스가 변경되는 상황이 발생할때 해당 로직은 모두 다시 만들어야 합니다.

마찬가지로 메세지브로커를 사용하는 경우 특정 브로커(예: 카프카, RabbitMQ 등 )의 호출 코드를 직접적으로 사용하지 않고, 어뎁터 형식으로 사용하는 방법이 좋습니다.

이처럼 비지니스 로직은 순수한 형태로 구현을 하고, 그 이외의 것을 adapter 형식으로 설계를 하여 해당 비지니스 로직이 어느 환경에서도 잘 동작하도록 설계한 모형이 헥사고날 아키텍처이고, 마이크로 서비스 아키텍처에서는 이와 같은 방식을 지향합니다.

./../../images/msasc/image1.b306fc5.1da719ff54ffae34e5cbc0d7f17d6974.png

### MSA Chassis
MSA Chassis 라는 말은 마이크로 서비스를 구축할때 필요한 프레임워크들의 모음입니다. 위에 설명한 헥사고날 아키텍처로 설계하여 비지니스 로직에 영향이 없는 개발을 맨땅에서 하려면 많은 공수가 필요합니다. 이에 많은 프레임워크들이 이와 같은 패턴들을 구성해 놓고 제공중입니다.

Java 계열에서 가장 선두주자인 Spring 프레임워크에서 마이크로 서비스에 적합한 spring-boot 프레임워크를 내어 놓았고, 이에 여러가지 어뎁터들에 해당하는 프로젝트들이 존재합니다. 아래 그림은 헥사고날 아키텍처에 spring-boot를 기반으로 한 MSA Chassis 를 입힌 모형입니다. Spring-Data-Rest 를 사용하여 Data 를 외부와 Rest 방식으로 연결시키고 , String-Cloud-Stream 으로 메세지 처리를 하는 로직을 구현하여 특정 브로커에 종속적이지 않은 adapter 패턴으로 구현된 모형입니다.

./../../images/msasc/image2.63ff18d.7a9da362f221e3a5cb1c658d48f813ff.png

### Outer 아키텍처
마이크로서비스 아키텍처는 Inner와 Outer 로 구분하고 있으며, Outer 아키텍처는 가트너에서 6개의 서브 영역(아래 참조)으로 세분화하고 있습니다.

./../../images/msasc/image3.e8fe0bf.10cb39929b9a4f32705376f3ff5d73b5.png

#### API Gateway
API Gateway는 마이크로서비스 외부로부터의 통합 접근을 위한 단일창구를 제공하며, 인증, 권한에 대한 통합 제어를 수행합니다.

#### Service Mesh
마이크로서비스의 네트워크 제어뿐만 아니라, 서비스간 Advanced한 호출 제어 및 트랜잭션을 관리 합니다.

#### Container Management
마이크로서비스를 물리적으로 적재하는 기반이며 논리적인 서비스 운영이 가능합니다. 컨테이너 기반의 대규모 마이크로서비스가 관리됩니다.

#### Backing Services
마이크로서비스에서 어플리케이션이 실행되는 가운데 네트워크를 통해서 사용할 수 있는 모든 서비스를 지칭합니다. 예를 들어 데이터베이스, 메시지/큐 시스템,  SMTP 서비스, 캐시 시스템이 있습니다.

#### Telemetry
마이크로서비스 아키텍처의 메트릭 기반 전 구간을 모니터링하며, 물리적으로 분산되어 운영되는 컨테이너 기반의 마이크로서비스에 대한 로그를 수집하고 서비스를 추적합니다.

#### CI/CD Automation
마이크로서비스의 소스Build에서부터 단위테스트와 컨트랙 테스트를 수행하는 Continuous Integration 영역과 도커 이미지를 생성해 운영 환경에 자동 배포되는 Continuous Deployment를 담당합니다.
